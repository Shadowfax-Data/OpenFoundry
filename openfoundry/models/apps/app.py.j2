import os
from pathlib import Path
import streamlit as st
from typing import NamedTuple

class ConnectionKey(NamedTuple):
    name: str
    type: str

def _get_connection_type(creds: dict[str, str]) -> str | None:
    """Determines connection type based on secret keys."""
    type_mapping = {
        "SNOWFLAKE_": "snowflake",
    }
    for key in creds:
        for prefix, conn_type in type_mapping.items():
            if key.startswith(prefix):
                return conn_type
    return None

@st.cache_data
def load_connection_secrets(base_dir: str = "/etc/secrets/connections"):
    """Recursively read each connectionâ€™s key-files into a dict."""
    conns: dict[ConnectionKey, dict[str, str]] = {}
    base = Path(base_dir)
    if not base.exists():
        st.warning(f"No secrets found at {base_dir}")
        return conns

    for conn_dir in base.iterdir():
        if conn_dir.is_dir():
            creds = {f.name: f.read_text().strip() for f in conn_dir.iterdir()}
            conn_type = _get_connection_type(creds)
            if conn_type:
                key = ConnectionKey(name=conn_dir.name, type=conn_type)
                conns[key] = creds
    return conns

connection_secrets = load_connection_secrets()

{% if 'snowflake' in available_connection_types %}
import snowflake.connector
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

@st.cache_resource
def get_snowflake_conn():
    connection_secrets = load_connection_secrets()
    SNOWFLAKE_CREDS = next((creds for key, creds in connection_secrets.items() if key.type == "snowflake"), {})

    """Establishes a connection to Snowflake, handling private key decoding."""
    if not SNOWFLAKE_CREDS:
        st.info("Snowflake connection secrets not found.")
        return None

    private_key_pem = SNOWFLAKE_CREDS.get("SNOWFLAKE_PRIVATE_KEY")
    if not private_key_pem:
        st.error("Private key not found in Snowflake secrets.")
        return None

    try:
        # Decode the private key
        p_key_bytes = private_key_pem.encode("utf-8")
        p_key = serialization.load_pem_private_key(
            p_key_bytes,
            password=None,  # Assuming the key is not password-protected
            backend=default_backend(),
        )

        # Create a copy of the creds and replace the key string with the key object
        conn_params = {
            "account": SNOWFLAKE_CREDS.get("SNOWFLAKE_ACCOUNT"),
            "user": SNOWFLAKE_CREDS.get("SNOWFLAKE_USER"),
            "private_key": p_key,
            "role": SNOWFLAKE_CREDS.get("SNOWFLAKE_ROLE"),
            "warehouse": SNOWFLAKE_CREDS.get("SNOWFLAKE_WAREHOUSE"),
            "database": SNOWFLAKE_CREDS.get("SNOWFLAKE_DATABASE"),
            "schema": SNOWFLAKE_CREDS.get("SNOWFLAKE_SCHEMA")
        }

        conn = snowflake.connector.connect(
            **conn_params,
            client_session_keep_alive=True,
        )

        # Execute a simple query to confirm the connection
        with conn:
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
                one_row = cur.fetchone()
                if one_row:
                    st.success(f"Successfully connected to Snowflake! Query 'SELECT 1' returned: {one_row[0]}")

    except Exception as e:
        st.error(f"Failed to connect to Snowflake: {e}")
        return None

conn = get_snowflake_conn()
{% endif %}


# Add a button
if st.button('Click me!'):
    st.write('Button clicked!')
    st.balloons()
