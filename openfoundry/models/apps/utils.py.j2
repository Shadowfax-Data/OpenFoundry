import os
from pathlib import Path
import streamlit as st
from typing import NamedTuple

class ConnectionKey(NamedTuple):
    name: str
    type: str

def _get_connection_type(creds: dict[str, str]) -> str | None:
    """Determines connection type based on secret keys."""
    type_mapping = {
        "SNOWFLAKE_": "snowflake",
    }
    for key in creds:
        for prefix, conn_type in type_mapping.items():
            if key.startswith(prefix):
                return conn_type
    return None

@st.cache_data
def load_connection_secrets(base_dir: str = "/etc/secrets/connections"):
    """Recursively read each connection key-files into a dict."""
    conns: dict[ConnectionKey, dict[str, str]] = {}
    base = Path(base_dir)
    if not base.exists():
        st.warning(f"No secrets found at {base_dir}")
        return conns

    for conn_dir in base.iterdir():
        if conn_dir.is_dir():
            creds = {f.name: f.read_text().strip() for f in conn_dir.iterdir()}
            conn_type = _get_connection_type(creds)
            if conn_type:
                key = ConnectionKey(name=conn_dir.name, type=conn_type)
                conns[key] = creds
    return conns

{% if 'snowflake' in available_connection_types %}
import snowflake.connector
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

@st.cache_resource
def get_snowflake_conn():
    connection_secrets = load_connection_secrets()
    SNOWFLAKE_CREDS = next((creds for key, creds in connection_secrets.items() if key.type == "snowflake"), {})

    """Establishes a connection to Snowflake, handling private key decoding."""
    if not SNOWFLAKE_CREDS:
        st.info("Snowflake connection secrets not found.")
        return None

    try:
        conn_params = {
            "account": SNOWFLAKE_CREDS.get("SNOWFLAKE_ACCOUNT"),
            "user": SNOWFLAKE_CREDS.get("SNOWFLAKE_USER"),
            "private_key": SNOWFLAKE_CREDS.get("SNOWFLAKE_PRIVATE_KEY"),
            "role": SNOWFLAKE_CREDS.get("SNOWFLAKE_ROLE"),
            "warehouse": SNOWFLAKE_CREDS.get("SNOWFLAKE_WAREHOUSE"),
            "database": SNOWFLAKE_CREDS.get("SNOWFLAKE_DATABASE"),
            "schema": SNOWFLAKE_CREDS.get("SNOWFLAKE_SCHEMA")
        }

        return snowflake.connector.connect(
            **conn_params,
            client_session_keep_alive=True,
        )

    except Exception as e:
        st.error(f"Failed to connect to Snowflake: {e}")
        return None

{% endif %}
