import os
from pathlib import Path
import streamlit as st
from typing import NamedTuple

class ConnectionKey(NamedTuple):
    name: str
    type: str

def _get_connection_type(creds: dict[str, str]) -> str | None:
    """Determines connection type based on secret keys."""
    type_mapping = {
        "SNOWFLAKE_": "snowflake",
        "DATABRICKS_": "databricks",
        "CLICKHOUSE_": "clickhouse",
        "POSTGRES_": "postgres",
    }
    for key in creds:
        for prefix, conn_type in type_mapping.items():
            if key.startswith(prefix):
                return conn_type
    return None

def load_connection_secrets(base_dir: str = "/etc/secrets/connections"):
    """Recursively read each connection key-files into a dict."""
    conns: dict[ConnectionKey, dict[str, str]] = {}
    base = Path(base_dir)
    if not base.exists():
        return conns

    for conn_dir in base.iterdir():
        if conn_dir.is_dir():
            creds = {f.name: f.read_text().strip() for f in conn_dir.iterdir()}
            conn_type = _get_connection_type(creds)
            if conn_type:
                key = ConnectionKey(name=conn_dir.name, type=conn_type)
                conns[key] = creds
    return conns

import snowflake.connector
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

def list_snowflake_connections():
    """Returns a list of available Snowflake connection names."""
    connection_secrets = load_connection_secrets()
    return [key.name for key, creds in connection_secrets.items() if key.type == "snowflake"]

def get_snowflake_conn(connection_name: str):
    """
    Establishes a connection to Snowflake, handling private key decoding.

    Args:
        connection_name: The name of the specific connection to use.

    Returns:
        Snowflake connection object or None if connection fails.
    """
    connection_secrets = load_connection_secrets()

    # Find the specific Snowflake connection directly
    snowflake_key = ConnectionKey(name=connection_name, type="snowflake")

    if snowflake_key not in connection_secrets:
        available_connections = [key.name for key, creds in connection_secrets.items() if key.type == "snowflake"]
        st.error(f"Snowflake connection '{connection_name}' not found. Available connections: {available_connections}")
        return None

    SNOWFLAKE_CREDS = connection_secrets[snowflake_key]

    try:
        conn_params = {
            "account": SNOWFLAKE_CREDS.get("SNOWFLAKE_ACCOUNT"),
            "user": SNOWFLAKE_CREDS.get("SNOWFLAKE_USER"),
            "private_key": SNOWFLAKE_CREDS.get("SNOWFLAKE_PRIVATE_KEY"),
            "role": SNOWFLAKE_CREDS.get("SNOWFLAKE_ROLE"),
            "warehouse": SNOWFLAKE_CREDS.get("SNOWFLAKE_WAREHOUSE"),
            "database": SNOWFLAKE_CREDS.get("SNOWFLAKE_DATABASE"),
            "schema": SNOWFLAKE_CREDS.get("SNOWFLAKE_SCHEMA")
        }

        return snowflake.connector.connect(
            **conn_params,
            client_session_keep_alive=True,
        )

    except Exception as e:
        st.error(f"Failed to connect to Snowflake connection '{connection_name}': {e}")
        return None

from databricks import sql

def list_databricks_connections():
    """Returns a list of available Databricks connection names."""
    connection_secrets = load_connection_secrets()
    return [key.name for key, creds in connection_secrets.items() if key.type == "databricks"]

def get_databricks_conn(connection_name: str):
    """
    Establishes a connection to Databricks.

    Args:
        connection_name: The name of the specific connection to use.

    Returns:
        Databricks connection object or None if connection fails.
    """
    connection_secrets = load_connection_secrets()

    # Find the specific Databricks connection directly
    databricks_key = ConnectionKey(name=connection_name, type="databricks")

    if databricks_key not in connection_secrets:
        available_connections = [key.name for key, creds in connection_secrets.items() if key.type == "databricks"]
        st.error(f"Databricks connection '{connection_name}' not found. Available connections: {available_connections}")
        return None

    DATABRICKS_CREDS = connection_secrets[databricks_key]

    try:
        conn_params = {
            "server_hostname": DATABRICKS_CREDS.get("DATABRICKS_HOST"),
            "http_path": DATABRICKS_CREDS.get("DATABRICKS_HTTP_PATH"),
            "access_token": DATABRICKS_CREDS.get("DATABRICKS_TOKEN"),
            "catalog": DATABRICKS_CREDS.get("DATABRICKS_CATALOG"),
            "schema": DATABRICKS_CREDS.get("DATABRICKS_SCHEMA"),
        }

        return sql.connect(**conn_params)

    except Exception as e:
        st.error(f"Failed to connect to Databricks connection '{connection_name}': {e}")
        return None

from clickhouse_connect import dbapi
import clickhouse_connect.common as clickhouse_common

def list_clickhouse_connections():
    """Returns a list of available ClickHouse connection names."""
    connection_secrets = load_connection_secrets()
    return [key.name for key, creds in connection_secrets.items() if key.type == "clickhouse"]

def get_clickhouse_conn(connection_name: str):
    """
    Establishes a connection to ClickHouse.

    Args:
        connection_name: The name of the specific connection to use.

    Returns:
        ClickHouse connection object or None if connection fails.
    """
    connection_secrets = load_connection_secrets()

    # Find the specific ClickHouse connection directly
    clickhouse_key = ConnectionKey(name=connection_name, type="clickhouse")

    if clickhouse_key not in connection_secrets:
        available_connections = [key.name for key, creds in connection_secrets.items() if key.type == "clickhouse"]
        st.error(f"ClickHouse connection '{connection_name}' not found. Available connections: {available_connections}")
        return None

    CLICKHOUSE_CREDS = connection_secrets[clickhouse_key]

    try:
        # Set ClickHouse connection settings for better compatibility
        clickhouse_common.set_setting('autogenerate_session_id', False)

        conn_params = {
            "host": CLICKHOUSE_CREDS.get("CLICKHOUSE_HOST"),
            "port": int(CLICKHOUSE_CREDS.get("CLICKHOUSE_PORT", 8443)),
            "username": CLICKHOUSE_CREDS.get("CLICKHOUSE_USERNAME"),
            "password": CLICKHOUSE_CREDS.get("CLICKHOUSE_PASSWORD"),
            "database": CLICKHOUSE_CREDS.get("CLICKHOUSE_DATABASE"),
            "secure": True,
        }

        return dbapi.connect(**conn_params)

    except Exception as e:
        st.error(f"Failed to connect to ClickHouse connection '{connection_name}': {e}")
        return None

import psycopg2

def list_postgres_connections():
    """Returns a list of available PostgreSQL connection names."""
    connection_secrets = load_connection_secrets()
    return [key.name for key, creds in connection_secrets.items() if key.type == "postgres"]

def get_postgres_conn(connection_name: str):
    """
    Establishes a connection to PostgreSQL.

    Args:
        connection_name: The name of the specific connection to use.

    Returns:
        PostgreSQL connection object or None if connection fails.
    """
    connection_secrets = load_connection_secrets()

    # Find the specific PostgreSQL connection directly
    postgres_key = ConnectionKey(name=connection_name, type="postgres")

    if postgres_key not in connection_secrets:
        available_connections = [key.name for key, creds in connection_secrets.items() if key.type == "postgres"]
        st.error(f"PostgreSQL connection '{connection_name}' not found. Available connections: {available_connections}")
        return None

    POSTGRES_CREDS = connection_secrets[postgres_key]

    try:
        conn_params = {
            "host": POSTGRES_CREDS.get("POSTGRES_HOST"),
            "port": int(POSTGRES_CREDS.get("POSTGRES_PORT", 5432)),
            "dbname": POSTGRES_CREDS.get("POSTGRES_DATABASE"),
            "user": POSTGRES_CREDS.get("POSTGRES_USER"),
            "password": POSTGRES_CREDS.get("POSTGRES_PASSWORD"),
        }

        # Add optional SSL mode if provided
        if POSTGRES_CREDS.get("POSTGRES_SSLMODE"):
            conn_params["sslmode"] = POSTGRES_CREDS.get("POSTGRES_SSLMODE")

        return psycopg2.connect(**conn_params)

    except Exception as e:
        st.error(f"Failed to connect to PostgreSQL connection '{connection_name}': {e}")
        return None
