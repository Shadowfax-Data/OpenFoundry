import os
from pathlib import Path
import streamlit as st
from typing import NamedTuple

class ConnectionKey(NamedTuple):
    name: str
    type: str

def _get_connection_type(creds: dict[str, str]) -> str | None:
    """Determines connection type based on secret keys."""
    type_mapping = {
        "SNOWFLAKE_": "snowflake",
        "DATABRICKS_": "databricks",
    }
    for key in creds:
        for prefix, conn_type in type_mapping.items():
            if key.startswith(prefix):
                return conn_type
    return None

def load_connection_secrets(base_dir: str = "/etc/secrets/connections"):
    """Recursively read each connection key-files into a dict."""
    conns: dict[ConnectionKey, dict[str, str]] = {}
    base = Path(base_dir)
    if not base.exists():
        return conns

    for conn_dir in base.iterdir():
        if conn_dir.is_dir():
            creds = {f.name: f.read_text().strip() for f in conn_dir.iterdir()}
            conn_type = _get_connection_type(creds)
            if conn_type:
                key = ConnectionKey(name=conn_dir.name, type=conn_type)
                conns[key] = creds
    return conns

import snowflake.connector
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

def list_snowflake_connections():
    """Returns a list of available Snowflake connection names."""
    connection_secrets = load_connection_secrets()
    return [key.name for key, creds in connection_secrets.items() if key.type == "snowflake"]

def get_snowflake_conn(connection_name: str):
    """
    Establishes a connection to Snowflake, handling private key decoding.

    Args:
        connection_name: The name of the specific connection to use.

    Returns:
        Snowflake connection object or None if connection fails.
    """
    connection_secrets = load_connection_secrets()

    # Find the specific Snowflake connection directly
    snowflake_key = ConnectionKey(name=connection_name, type="snowflake")

    if snowflake_key not in connection_secrets:
        available_connections = [key.name for key, creds in connection_secrets.items() if key.type == "snowflake"]
        st.error(f"Snowflake connection '{connection_name}' not found. Available connections: {available_connections}")
        return None

    SNOWFLAKE_CREDS = connection_secrets[snowflake_key]

    try:
        conn_params = {
            "account": SNOWFLAKE_CREDS.get("SNOWFLAKE_ACCOUNT"),
            "user": SNOWFLAKE_CREDS.get("SNOWFLAKE_USER"),
            "private_key": SNOWFLAKE_CREDS.get("SNOWFLAKE_PRIVATE_KEY"),
            "role": SNOWFLAKE_CREDS.get("SNOWFLAKE_ROLE"),
            "warehouse": SNOWFLAKE_CREDS.get("SNOWFLAKE_WAREHOUSE"),
            "database": SNOWFLAKE_CREDS.get("SNOWFLAKE_DATABASE"),
            "schema": SNOWFLAKE_CREDS.get("SNOWFLAKE_SCHEMA")
        }

        return snowflake.connector.connect(
            **conn_params,
            client_session_keep_alive=True,
        )

    except Exception as e:
        st.error(f"Failed to connect to Snowflake connection '{connection_name}': {e}")
        return None

from databricks import sql

def list_databricks_connections():
    """Returns a list of available Databricks connection names."""
    connection_secrets = load_connection_secrets()
    return [key.name for key, creds in connection_secrets.items() if key.type == "databricks"]

def get_databricks_conn(connection_name: str):
    """
    Establishes a connection to Databricks.

    Args:
        connection_name: The name of the specific connection to use.

    Returns:
        Databricks connection object or None if connection fails.
    """
    connection_secrets = load_connection_secrets()

    # Find the specific Databricks connection directly
    databricks_key = ConnectionKey(name=connection_name, type="databricks")

    if databricks_key not in connection_secrets:
        available_connections = [key.name for key, creds in connection_secrets.items() if key.type == "databricks"]
        st.error(f"Databricks connection '{connection_name}' not found. Available connections: {available_connections}")
        return None

    DATABRICKS_CREDS = connection_secrets[databricks_key]

    try:
        conn_params = {
            "server_hostname": DATABRICKS_CREDS.get("DATABRICKS_HOST"),
            "http_path": DATABRICKS_CREDS.get("DATABRICKS_HTTP_PATH"),
            "access_token": DATABRICKS_CREDS.get("DATABRICKS_TOKEN"),
            "catalog": DATABRICKS_CREDS.get("DATABRICKS_CATALOG"),
            "schema": DATABRICKS_CREDS.get("DATABRICKS_SCHEMA"),
        }

        return sql.connect(**conn_params)

    except Exception as e:
        st.error(f"Failed to connect to Databricks connection '{connection_name}': {e}")
        return None
