import os
from pathlib import Path
import streamlit as st
from typing import NamedTuple

class ConnectionKey(NamedTuple):
    name: str
    type: str

def _get_connection_type(creds: dict[str, str]) -> str | None:
    """Determines connection type based on secret keys."""
    type_mapping = {
        "SNOWFLAKE_": "snowflake",
    }
    for key in creds:
        for prefix, conn_type in type_mapping.items():
            if key.startswith(prefix):
                return conn_type
    return None

def load_connection_secrets(base_dir: str = "/etc/secrets/connections"):
    """Recursively read each connection key-files into a dict."""
    conns: dict[ConnectionKey, dict[str, str]] = {}
    base = Path(base_dir)
    if not base.exists():
        return conns

    for conn_dir in base.iterdir():
        if conn_dir.is_dir():
            creds = {f.name: f.read_text().strip() for f in conn_dir.iterdir()}
            conn_type = _get_connection_type(creds)
            if conn_type:
                key = ConnectionKey(name=conn_dir.name, type=conn_type)
                conns[key] = creds
    return conns

import snowflake.connector
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

def list_snowflake_connections():
    """Returns a list of available Snowflake connection names."""
    connection_secrets = load_connection_secrets()
    return [key.name for key, creds in connection_secrets.items() if key.type == "snowflake"]

def get_snowflake_conn(connection_name: str):
    """
    Establishes a connection to Snowflake, handling private key decoding.

    Args:
        connection_name: The name of the specific connection to use.

    Returns:
        Snowflake connection object or None if connection fails.
    """
    connection_secrets = load_connection_secrets()

    # Get all Snowflake connections
    snowflake_connections = {key.name: creds for key, creds in connection_secrets.items() if key.type == "snowflake"}

    if not snowflake_connections:
        return None

    # Select the appropriate connection
    if connection_name in snowflake_connections:
        SNOWFLAKE_CREDS = snowflake_connections[connection_name]
    else:
        available_connections = list(snowflake_connections.keys())
        st.error(f"Snowflake connection '{connection_name}' not found. Available connections: {available_connections}")
        return None

    try:
        conn_params = {
            "account": SNOWFLAKE_CREDS.get("SNOWFLAKE_ACCOUNT"),
            "user": SNOWFLAKE_CREDS.get("SNOWFLAKE_USER"),
            "private_key": SNOWFLAKE_CREDS.get("SNOWFLAKE_PRIVATE_KEY"),
            "role": SNOWFLAKE_CREDS.get("SNOWFLAKE_ROLE"),
            "warehouse": SNOWFLAKE_CREDS.get("SNOWFLAKE_WAREHOUSE"),
            "database": SNOWFLAKE_CREDS.get("SNOWFLAKE_DATABASE"),
            "schema": SNOWFLAKE_CREDS.get("SNOWFLAKE_SCHEMA")
        }

        return snowflake.connector.connect(
            **conn_params,
            client_session_keep_alive=True,
        )

    except Exception as e:
        st.error(f"Failed to connect to Snowflake connection '{connection_name}': {e}")
        return None
